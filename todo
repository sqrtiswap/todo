#!/bin/sh

create_task() {
	shift 1 && echo "(A) $(date +%F)" "$@" >> "$TODODIR/todo.txt"
	awk '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}END{printf "%4s %s\n", cs NR ce, cs $0 ce}' "$TODODIR/todo.txt"
}

append() {
	[ "$3" != '' ] && [ "$4" != '' ] && sed -i "$3"'s/$/ '"$4"'/' "$TODODIR/todo.txt" && awk -v pat="$3" '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{if(NR==pat)print cs $0 ce}' "$TODODIR/todo.txt"
}

list_finished() {
	$PAGER "$TODODIR/done.txt"
}

mark_done() {
	[ "$2" != '' ] && pat="$2" && echo "x $(date +%F)" "$(sed -n "${pat}p" "$TODODIR/todo.txt")" >> "$TODODIR/done.txt" && sed -i "${pat}d" "$TODODIR/todo.txt" && tail -1 "$TODODIR/done.txt"
	# different version that removes the priority of the finished task:
	#[ "$2" != '' ] && pat="$2" && echo "x $(date +%F)" "$(sed -e 's/(.) //g;'"${pat}"'q;d' "$TODODIR/todo.txt")" >> "$TODODIR/done.txt" && sed -i "${pat}d" "$TODODIR/todo.txt" && tail -1 "$TODODIR/done.txt"
}

edit_task() {
	$EDITOR "$TODODIR/todo.txt"
}

#list_tasks() {
	#awk -v pat="$2" 'index($0, pat){printf "%4s %s\n", NR, $0}' "$TODODIR/todo.txt" | sort -k2 | awk '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{print cs$0ce}'
#}
	# This version does not currently support case insensitive matching.

# Regular expressions conflict with the identifier + for projects. The above version of list_tasks() fixes this inside of todo(1). But if you want to manipulate the output later with regexp or even search for a term containing the + (e.g. a project like +work) you're gonna run into problems. The following version of list_tasks() is a standard implementation, meaning:
# 1) todo(1) with this second list_tasks() will break when using + as an identifier for projects. USE A DIFFERENT IDENTIFIER.
# 2) When using a different identifier and this second version of list_tasks(), you can manipulate your output with regexp all day long and also search for a full project term (e.g. a project like _work).

list_tasks() {
	awk -v pat="$2" '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"} tolower($0) ~ pat {printf cs"%4s %s\n", NR, $0ce}' "$TODODIR/todo.txt" | sort -i -t '\(' -k2
}

list_contexts() {
	grep -oh '[[:alnum:]]*@[[:alnum:]]*' "$TODODIR/todo.txt" | sort -u
}

list_projects() {
	grep -oh '[[:alnum:]]*_[[:alnum:]]*' "$TODODIR/todo.txt" | sort -u
	# Use the + for the first list_tasks() version.
	# Use something else (like _) for the second version so that the regexp work.
}

priority_change() {
	[ "$2" != '' ] && [ "$3" != '' ] && sed -i "$2"'s/(.)/('"$3"')/' "$TODODIR/todo.txt" && awk -v pat="$2" '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{if(NR==pat)print cs $0 ce}' "$TODODIR/todo.txt"
}

report() {
	echo "$(date +%FT%TZ) $(awk 'END{print NR}' "$TODODIR/todo.txt") $(awk 'END{print NR}' "$TODODIR/done.txt")" >> "$TODODIR/report.txt" && tail -1 "$TODODIR/report.txt"
}

today() {
	DUETODAY=$(grep -c "$(date +%F)" "$TODODIR"/todo.txt)
	DUEURGENT=$(grep -c _urgent "$TODODIR"/todo.txt)
	echo "todo: Current tasks"
	if [ "$DUETODAY" != 0 ] ; then
		echo "---> Due today, $(date '+%d %B %Y')"
		list_tasks "" "due:$(date +%F)"
		if [ "$DUEURGENT" != 0 ] ; then
			echo "---> Due urgently/overdue"
			list_tasks "" "_urgent"
		fi
	elif [ "$DUETODAY" = 0 ] && [ "$DUEURGENT" != 0 ] ; then
		echo "---> Nothing due today, $(date '+%d %B %Y')"
		echo "---> Due urgently/overdue"
		list_tasks "" "_urgent"
	else
		echo "Nothing due! ;)"
	fi
}

usage() { printf "todo(1) version 0.8.2 - simple todo list manager.

=> append [number of task] [text]	- Append [text] to a task.
=> create [text]			- Create a new entry.
=> done [number of task]		- Mark the task as done.
=> edit					- Edit todo.txt in EDITOR.
=> finished				- Show finished items in PAGER.
=> ls					- List current todo list. This only accepts lowercase letters but matches in a case-insensitive manner.
=> lc					- List all contexts currently in use.
=> lp					- List all projects currently active.
=> priority [number of task] [priority]	- Change priority of a task to [priority] (A-Z).
=> report				- Create a report of the day containing the number of active and finished tasks.
=> today				- List all tasks due today and also those marked _urgent.

=> help					- Show this message.
Alternatively read the manpage.

Expected environment variables:
=> EDITOR		- The editor you want to use, when opening todo.txt
=> PAGER		- The pager you want to use, when taking a look at accomplished tasks.
=> TODODIR		- The directory where associated files are stored.

todo expects your files to be in TODODIR/
	todo.txt	- Current todo list containing active items
	done.txt	- List of finished items
	report.txt	- List of reports

The syntax of todo.txt, specifically the + identifier for projects conflicts with regular expressions in awk. If you want to manipulate the output later on or list full project names, you're gonna have to tweak some of the functions a little - I included some guiding comments.

Since version 0.7 the tweaked list_tasks() function is used, resulting in the project identifier being changed from + to _ (+work -> _work).
"
exit 1
}

case $1 in
	a*) append "$@" ;;
	c*) create_task "$@" ;;
	d*) mark_done "$@" ;;
	e*) edit_task "$@" ;;
	f*) list_finished ;;
	ls) list_tasks "$@" ;;
	lc) list_contexts ;;
	lp) list_projects ;;
	p*) priority_change "$@" ;;
	r*) report ;;
	t*) today ;;
	*) usage
esac
