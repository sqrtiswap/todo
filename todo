#!/bin/sh

main() {
	case $1 in
		a*) add "$@" ;;
		d*) didit "$@" ;;
		e*) edit "$@" ;;
		f*) finished ;;
		ls) ls "$@" ;;
		lc) lscon ;;
		lp) lsprj ;;
		p*) prio "$@" ;;
		r*) report ;;
		t*) today ;;
		h*) usage ;;
		*)
	esac
}

add() {
	shift 1 && echo "(A) $(date +%F)" "$@" >> "$TODODIR/todo.txt"
	awk '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}END{printf "%4s %s\n", cs NR ce, cs $0 ce}' "$TODODIR/todo.txt"
}

append() {
	[ "$3" != '' ] && [ "$4" != '' ] && sed -i "$3"'s/$/ '"$4"'/' "$TODODIR/todo.txt" && awk -v pat="$3" '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{if(NR==pat)print cs $0 ce}' "$TODODIR/todo.txt"
}

finished() {
	$PAGER "$TODODIR/done.txt"
}

didit() {
	[ "$2" != '' ] && pat="$2" && echo "x $(date +%F)" "$(sed -n "${pat}p" "$TODODIR/todo.txt")" >> "$TODODIR/done.txt" && sed -i "${pat}d" "$TODODIR/todo.txt" && tail -1 "$TODODIR/done.txt"
	# different version that removes the priority of the finished task:
	#[ "$2" != '' ] && pat="$2" && echo "x $(date +%F)" "$(sed -e 's/(.) //g;'"${pat}"'q;d' "$TODODIR/todo.txt")" >> "$TODODIR/done.txt" && sed -i "${pat}d" "$TODODIR/todo.txt" && tail -1 "$TODODIR/done.txt"
}

edit() {
	case $2 in
		a*) append "$@" ;;
		*) $EDITOR "$TODODIR/todo.txt"
	esac
}

#ls() {
	#awk -v pat="$2" 'index($0, pat){printf "%4s %s\n", NR, $0}' "$TODODIR/todo.txt" | sort -k2 | awk '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{print cs$0ce}'
#}
	# This version does not currently support case insensitive matching.

# Regular expressions conflict with the identifier + for projects. The above version of ls() fixes this inside of todo(1). But if you want to manipulate the output later with regexp or even search for a term containing the + (e.g. a project like +work) you're gonna run into problems. The following version of ls() is a standard implementation, meaning:
# 1) todo(1) with this second ls() will break when using + as an identifier for projects. USE A DIFFERENT IDENTIFIER.
# 2) When using a different identifier and this second version of ls(), you can manipulate your output with regexp all day long and also search for a full project term (e.g. a project like _work).

ls() {
	awk -v pat="$2" '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"} tolower($0) ~ pat {printf cs"%4s %s\n", NR, $0ce}' "$TODODIR/todo.txt" | sort -i -t '\(' -k2
}

lscon() {
	grep -oh '[[:alnum:]]*@[[:alnum:]]*' "$TODODIR/todo.txt" | sort -u
}

lsprj() {
	grep -oh '[[:alnum:]]*_[[:alnum:]]*' "$TODODIR/todo.txt" | sort -u
	# Use the + for the first ls() version.
	# Use something else (like _) for the second version so that the regexp work.
}

prio() {
	[ "$2" != '' ] && [ "$3" != '' ] && sed -i "$2"'s/(.)/('"$3"')/' "$TODODIR/todo.txt" && awk -v pat="$2" '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{if(NR==pat)print cs $0 ce}' "$TODODIR/todo.txt"
}

report() {
	echo "$(date +%FT%TZ) $(awk 'END{print NR}' "$TODODIR/todo.txt") $(awk 'END{print NR}' "$TODODIR/done.txt")" >> "$TODODIR/report.txt" && tail -1 "$TODODIR/report.txt"
}

today() {
	echo "----- due:today -----"
	todo ls due:"$(date +%Y-%m-%d)"
	echo "----- _urgent -------"
	todo ls _urgent
}

usage() { printf "todo(1) version 0.8p0 - simple todo list manager.

=> a[dd] [entry]			- Create a new entry.
=> d[one] [entry]			- Mark [entry] as done.
=> e[dit] [entry]			- Edit [entry] in your EDITOR.
=> e[dit] a[ppend] [entry] [text]	- Appends [text] to [entry].
=> f[inished]				- Show finished items.
=> ls					- List current todo list. This works in a case-insensitive manner.
=> lc					- List all contexts currently in use.
=> lp					- List all projects currently active.
=> p [entry] [priority]			- Set/Change priority of [entry] to [priority] (A-Z).
=> r[eport]				- Create a report of the day containing the number of active and finished tasks.
=> t[oday]				- List all tasks due today and also those marked _urgent.

=> h[help]				- Show this message.
Alternatively read the manpage.

Expected environment variables:
=> EDITOR		- The editor you want to use, when opening todo.txt
=> PAGER		- The pager you want to use, when taking a look at accomplished tasks.
=> TODODIR		- The directory where associated files are stored.

todo expects your files to be in TODODIR/
	todo.txt	- Current todo list containing active items
	done.txt	- List of finished items
	report.txt	- List of reports

The syntax of todo.txt, specifically the + identifier for projects conflicts with regular expressions in awk. If you want to manipulate the output later on or list full project names, you're gonna have to tweak some of the functions a little - I included some guiding comments.

Since version 0.7 the tweaked ls() function is used, resulting in the project identifier being changed from + to _ (+work -> _work).
"
exit 0
}

[ "$1" ] || usage && main "$@"
