#!/bin/sh

main() {
	case $1 in
		a*) add "$@" ;;
		d*) didit "$@" ;;
		e*) edit "$@" ;;
		f*) finished ;;
		ls) ls "$@" ;;
		lc) lscon ;;
		lp) lsprj ;;
		p*) prio "$@" ;;
		r*) report ;;
		h*) usage ;;
		*)
	esac
}

add() {
	shift 1 && echo "(A) $(date +%F)" "$@" >> "$TODODIR/todo.txt"
	awk '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}END{printf "%4s %s\n", cs NR ce, cs $0 ce}' "$TODODIR/todo.txt"
}

append() {
	[ "$3" != '' ] && [ "$4" != '' ] && sed -i "$3"'s/$/ '"$4"'/' "$TODODIR/todo.txt" && awk -v pat="$3" '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{if(NR==pat)print cs $0 ce}' "$TODODIR/todo.txt"
}

finished() {
	$PAGER "$TODODIR/done.txt"
}

didit() {
	[ "$2" != '' ] && pat="$2" && echo "x $(date +%F)" "$(sed -n "${pat}p" "$TODODIR/todo.txt")" >> "$TODODIR/done.txt" && sed -i "${pat}d" "$TODODIR/todo.txt" && tail -1 "$TODODIR/done.txt"
	# different version that removes the priority of the finished task:
	#[ "$2" != '' ] && pat="$2" && echo "x $(date +%F)" "$(sed -e 's/(.) //g;'"${pat}"'q;d' "$TODODIR/todo.txt")" >> "$TODODIR/done.txt" && sed -i "${pat}d" "$TODODIR/todo.txt" && tail -1 "$TODODIR/done.txt"
}

edit() {
	case $2 in
		a*) append "$@" ;;
		*) $EDITOR "$TODODIR/todo.txt"
	esac
}

ls() {
	awk -v pat="$2" 'index($0, pat){printf "%4s %s\n", NR, $0}' "$TODODIR/todo.txt" | sort -k2 | awk '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{print cs$0ce}'
}

# Regular expressions conflict with the identifier + for projects. The above version of ls() fixes this inside of todo(1). But if you want to manipulate the output later with regexp you're gonna run into problems. The following version of ls() is a standard implementation, meaning:
# 1) todo(1) with this second ls() will break when using + as an identifier for projects. USE A DIFFERENT IDENTIFIER.
# 2) When using a different identifier and this second version of ls(), you can manipulate your output with regexp all day long.

#ls() {
	#awk -v pat="$2" '$0 ~ pat {printf "%4s %s\n", NR, $0}' "$TODODIR/todo.txt" | sort -k2 | awk '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;32m"}/\(C\)/{cs="\033[1;33m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{print cs$0ce}'
#}

lscon() {
	grep -oh '[[:alnum:]]*@[[:alnum:]]*' "$TODODIR/todo.txt" | sort -u
}

lsprj() {
	grep -oh '[[:alnum:]]*+[[:alnum:]]*' "$TODODIR/todo.txt" | sort -u
	# change the + if you want your regexps to succeed
}

prio() {
	[ "$2" != '' ] && [ "$3" != '' ] && sed -i "$2"'s/(.)/('"$3"')/' "$TODODIR/todo.txt" && awk -v pat="$2" '{ce="\033[0m"}/\(A\)/{cs="\033[1;31m"}/\(B\)/{cs="\033[1;33m"}/\(C\)/{cs="\033[1;32m"}/\(D\)/{cs="\033[1;34m"}/\(E\)/{cs="\033[0m"}{if(NR==pat)print cs $0 ce}' "$TODODIR/todo.txt"
}

report() {
	echo "$(date +%FT%TZ) $(awk 'END{print NR}' "$TODODIR/todo.txt") $(awk 'END{print NR}' "$TODODIR/done.txt")" >> "$TODODIR/report.txt" && tail -1 "$TODODIR/report.txt"
}

usage() { printf "todo(1) version 0.6p1 - simple todo list manager.

=> a[dd] [entry]			- Create a new entry.
=> d[one] [entry]			- Mark [entry] as done.
=> e[dit] [entry]			- Edit [entry] in your EDITOR.
=> e[dit] a[ppend] [entry] [text]	- Appends [text] to [entry].
=> f[inished]				- Show finished items.
=> ls					- List current todo list.
=> lc					- List all contexts currently in use.
=> lp					- List all projects currently active.
=> p [entry] [priority]			- Set/Change priority of [entry] to [priority] (A-Z).
=> r[eport]				- Create a report of the day containing the number of active and finished tasks.

=> h[help]				- Show this message.
Alternatively read the manpage.

Expected environment variables:
=> EDITOR		- The editor you want to use, when opening todo.txt
=> PAGER		- The pager you want to use, when taking a look at accomplished tasks.
=> TODODIR		- The directory where associated files are stored.

todo expects your files to be in TODODIR/
	todo.txt	- Current todo list containing active items
	done.txt	- List of finished items
	report.txt	- List of reports

The syntax of todo.txt, specifically the + identifier for projects conflicts with regular expressions in awk. If you want to manipulate the output later on, you're gonna have to tweak some of the functions a little - I included some guiding comments.
"
exit 0
}

[ "$1" ] || usage && main "$@"
